#!/usr/bin/env perl
# Woger - make a release
my $version_banner = <<END;
Woger welease 27
Copyright (c) Reuben Thomas 2007-2013
Released under the GPL version 3, or (at your option) any later version.
END

# FIXME: Add methods rsync (e.g. for web sites), log (to announce on my log)

# Dependencies:
#   For email: mail that supports -a for attachment (e.g. heirloom-mailx)
#   For SourceForge: copher: http://copher.sourceforge.net/
#   For Freecode: freecode-submit: http://www.catb.org/~esr/freecode-submit/

use 5.10.0;

use warnings;
use strict;

use Perl6::Slurp;
use Text::Wrap;
use Set::Scalar;

use File::Basename;
use Getopt::Long;

my $prog = basename($0);
my ($help_flag, $version_flag, $vars_flag, $dry_run_flag);

my %var_help = (
  package => "package base name",
  package_name => "package text name",
  version => "version number",
  revision => "packaging revision number",
  description => "short project description",
  dist_type => "file extension for distribution archive",
  email => "release email",
  notes => "release notes file",
  home => "home page URL",
  upload => "upload URL",
);


# Release methods

my %releaser = ();
my %vars;

%{$releaser{null}} = (
  vars => Set::Scalar->new,
  release => sub {
  }
 );

%{$releaser{freecode}} = (
  vars => Set::Scalar->new("package", "notes", "version"),
  release => sub {
    open(FILE, "|-", "freecode-submit");
    print FILE "Project: $vars{package}\nVersion: $vars{version}\n\n" . slurp($vars{notes});
    close FILE or die "freecode-submit failed\n";
  }
 );

%{$releaser{gnu}} = (
  vars => Set::Scalar->new("dist_type", "email", "package", "package_name", "upload", "version"),
  release => sub {
    # FIXME: Get the command in the next line from the output of make {alpha,beta,stable}
    run("./build-aux/gnupload", "--to", "$vars{upload}:$vars{package}",
        "$vars{package}-$vars{version}.$vars{dist_type}") == 0
          or die "gnupload failed\n";

    my $url = "$vars{upload}/gnu/$vars{package}/$vars{package}-$vars{version}.tar";

    # Wait for URL to become available:
    for (my $i = 0; $i < 100; $i++) {
      run("wget", "--quiet", "-O", "-", "$url.gz.sig") and last;
      sleep 10;
    }

    # Download and verify xz and gz signatures
    # FIXME: Get correct suffixes (e.g. xz xz.sig bz2 bz2.sig) automatically
    for my $i ("gz", "gz.sig") {
      run("wget", "--quiet", "$url.$i") or last;
      run("gpg", "--verify", basename($url) . ".$i") if $i =~ /\.sig$/;
    }
    my $message = slurp($vars{email});
    $message =~ s/^\n//s;
    mail($message); # FIXME: Cope with Mail-Followup-To header
  }
 );

%{$releaser{luarocks}} = (
  vars => Set::Scalar->new("package", "package_name", "version"),
  release => sub {
    my $revision = $vars{revision} || "1";
    my $rock_suffix = "-$revision.rockspec";
    my @rockspecs = glob ("$vars{package}-*$vars{version}$rock_suffix");
    my @rocks = @rockspecs;
    my $rocks = join ", ", map { s/$rock_suffix$//; $_ } @rocks;
    my $plural = $#rockspecs > 0 ? "s" : "";
    mail("Rockspec$plural for $vars{package} version $vars{version} attached.",
         "luarocks-developers\@lists.sourceforge.net",
         "[ANN] $vars{package_name} $vars{version} released; rockspec$plural attached",
         @rockspecs);
  }
 );

%{$releaser{lua}} = (
  vars => Set::Scalar->new("description", "home", "notes", "package", "package_name", "version"),
  release => sub {
    my $release_notes = slurp($vars{notes});
    chomp $release_notes;
    my $revision = $vars{revision} || "1";
    my $rock_suffix = "-$revision.rockspec";
    my @rockspecs = glob ("$vars{package}-*$vars{version}$rock_suffix");
    my @rocks = @rockspecs;
    my $rocks = join ", ", map { s/$rock_suffix$//; $_ } @rocks;
    my $message = <<END;
I am happy to announce the release of $vars{package_name} $vars{version},
$vars{description}.

$release_notes

Install it as luarock $rocks (see http://luarocks.org/repositories/rocks )

Most simply:

  luarocks install $vars{package}

(You may need to wait a while after this announcement lands before the
rocks are available.)

$vars{package_name}'s home page is at $vars{home}
END
    mail($message, "lua-l\@lists.lua.org", "[ANN] $vars{package_name} $vars{version} released");
    $releaser{luarocks}{release}();
  }
 );

%{$releaser{sourceforge}} = (
  vars => Set::Scalar->new("dist_type", "notes", "package", "version"),
  release => sub {
    run("copher", "-p", $vars{package}, "-k", $vars{package}, "-r", $vars{version},
        "-N", $vars{notes}, "$vars{package}-$vars{version}.$vars{dist_type}") == 0
          or die "copher failed\n";
    unlink "out.html";
  }
 );


sub run {
  return system @_ unless $dry_run_flag;
  print "Command: ", (join " ", @_);
  return 1;
}

sub mail {
  my ($body, $address, $subject, @attachments) = @_;
  my @args;
  push @args, "-a", $_ foreach @attachments;
  push @args, "-s", $subject if $subject;
  if ($address) {
    push @args, $address;
  } else {
    push @args, "-t";
  }
  unless ($dry_run_flag) {
    open(FILE, "|-", "mail", @args);
    print FILE wrap('', '', ($body));
    close FILE or die "mail to $address failed\n";
  } else {
    print wrap('', '', "Email to: $address\n$subject\n\n$body\n");
  }
}

my $methods = join ", ", keys %releaser;

sub usage {
  my ($exit_code) = @_;
  print STDERR <<END;
$prog [OPTION...] METHODS [VARIABLE=value...]
Release a program.

  METHODS is a comma-separated list of methods, from:
    $methods

 Options:
  --dry-run                  don't do anything, just display what would be done
  --vars                     display the variables needed by METHODS and exit
  --help                     display this help and exit
  --version                  display version information and exit
END
  exit $exit_code;
}

# Get arguments
my $opts = GetOptions(
  "dry-run", \$dry_run_flag,
  "help" => \$help_flag,
  "version" => \$version_flag,
  "vars" => \$vars_flag,
) or usage(1);
if ($version_flag) {
  print STDERR $version_banner;
  exit 0;
}
usage(0) if $help_flag or $#ARGV == -1;
my @methods = split /,/, shift;
foreach my $arg (@ARGV) {
  $arg =~ s/([A-Za-z0-9_]+)\s*=\s*(.*)/$vars{$1} = $2/e;
}

# Check all methods are known
@methods = grep {
  if (!defined ($releaser{$_})) {
    die "no such method $_\n";
  } else {
    1;
  }
} @methods;

# Make a set of all needed variables
my $needed = Set::Scalar->new();
$needed = $needed->union($releaser{$_}{vars}) foreach @methods;

# Write release notes if needed
if ($needed->has("notes")) {
  $vars{notes} ||= "release-notes";
  if (!-e $vars{notes}) {
    die "VISUAL is not set; please set it!\n"
      if -z $ENV{VISUAL};
    system($ENV{VISUAL} . " " . $vars{notes}) == 0 or die "editor failed\n";
  }
}

# Complain about missing variables
my $missing;
foreach my $e ($needed->elements) {
  unless ($vars{$e}) {
    print STDERR "Variable $e missing\n";
    $missing = 1;
  }
}
if ($vars_flag || $missing) {
  print STDERR "Variables needed:\n";
  print STDERR "  $_: $var_help{$_}\n" foreach (sort $needed->elements);
  exit $missing;
}

# Welease!
for my $method (@methods) {
  $releaser{$method}{release}();
}
