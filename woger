#!/usr/bin/env perl
# Woger - make a release
my $version_banner = <<END;
Woger welease 38
Copyright (c) Reuben Thomas 2007-2020
Released under the GPL version 3, or (at your option) any later version.
END

# On Ubuntu/Debian:
# apt-get install libperl6-slurp-perl libset-scalar-perl s-nail luarocks
# (copher and hub are not packaged in Ubuntu/Debian)

# Program dependencies:
#   For email: S-nail: http://www.sdaoden.eu/code.html
#   For SourceForge: copher: http://copher.sourceforge.net/
#   For GitHub: hub: https://hub.github.com/
#   For LuaRocks: luarocks: https://luarocks.org/

use 5.10.0;

use warnings;
use strict;

use File::Basename;
use Getopt::Long;
use Text::Wrap;

use Perl6::Slurp;
use Set::Scalar;

my $prog = basename($0);
my ($help_flag, $version_flag, $vars_flag, $dry_run_flag);

my %var_help = (
  package => "package base name",
  package_name => "package text name",
  version => "version number",
  revision => "packaging revision number",
  description => "short project description",
  dist_type => "file extension for distribution archive",
  email => "release email",
  notes => "release notes file",
  home => "home page URL",
  upload => "upload URL",
);


# Release methods

my %releaser = ();
my %vars;

%{$releaser{null}} = (
  vars => Set::Scalar->new,
  release => sub {
  }
 );

%{$releaser{gnu}} = (
  vars => Set::Scalar->new("dist_type", "email", "package", "package_name", "upload", "version"),
  release => sub {
    # FIXME: Get the command in the next line from the output of make {alpha,beta,stable}
    run("./build-aux/gnupload", "--to", "$vars{upload}:$vars{package}",
        "$vars{package}-$vars{version}.$vars{dist_type}") == 0
          or die "gnupload failed\n";

    my $url = "$vars{upload}/gnu/$vars{package}/$vars{package}-$vars{version}.tar";

    # Wait for URL to become available:
    for (my $i = 0; $i < 100; $i++) {
      run("wget", "--quiet", "-O", "-", "$url.gz.sig") and last;
      sleep 10;
    }

    # Download and verify xz and gz signatures
    # FIXME: Get correct suffixes (e.g. xz xz.sig bz2 bz2.sig) automatically
    for my $i ("gz", "gz.sig") {
      run("wget", "--quiet", "$url.$i") or last;
      run("gpg", "--verify", basename($url) . ".$i") if $i =~ /\.sig$/;
    }
    my $message = slurp($vars{email});
    $message =~ s/^\n//s;
    mail($message); # FIXME: Cope with Mail-Followup-To header
  }
 );

%{$releaser{luarocks}} = (
  vars => Set::Scalar->new("package", "version"),
  release => sub {
    my $revision = $vars{revision} || "1";
    my $rock_suffix = "-$revision.rockspec";
    my @rockspecs = glob("$vars{package}-*$vars{version}$rock_suffix");
    for my $r (@rockspecs) {
      run("luarocks", "upload", $r);
    }
  }
 );

%{$releaser{lua}} = (
  vars => Set::Scalar->new("description", "home", "notes", "package", "package_name", "version"),
  release => sub {
    my $release_notes = slurp($vars{notes});
    chomp $release_notes;
    my $revision = $vars{revision} || "1";
    my $rock_suffix = "-$revision.rockspec";
    my @rockspecs = glob("$vars{package}-*$vars{version}$rock_suffix");
    my @rocks = @rockspecs;
    my $rocks = join ", ", map { s/$rock_suffix$//; $_ } @rocks;
    my $plural = $#rockspecs > 0 ? "s" : "";
    my $message = <<END;
I am happy to announce the release of $vars{package_name} $vars{version},
$vars{description}.

$release_notes

Install it as luarock$plural $rocks (see http://luarocks.org/ )

Most simply:

  luarocks install $vars{package}

$vars{package_name}'s home page is at $vars{home}
END
    mail($message, "lua-l\@lists.lua.org", "[ANN] $vars{package_name} $vars{version} released");
    $releaser{luarocks}{release}();
  }
 );

%{$releaser{sourceforge}} = (
  vars => Set::Scalar->new("dist_type", "notes", "package", "version"),
  release => sub {
    run("copher", "-p", $vars{package}, "-k", $vars{package}, "-r", $vars{version},
        "-N", $vars{notes}, "$vars{package}-$vars{version}.$vars{dist_type}") == 0
          or die "copher failed\n";
    unlink "out.html";
  }
 );

# FIXME: add support for description, using -F - (replaces --message)
%{$releaser{github}} = (
  vars => Set::Scalar->new("dist_type", "package", "version"),
  release => sub {
    my $tag = "v$vars{version}";
    run("hub", "release", "create", "$tag", "--message", "Release $tag",
        "--attach", "$vars{package}-$vars{version}.$vars{dist_type}") == 0
          or die "hub release failed\n";
  }
 );


sub run {
  return system @_ unless $dry_run_flag;
  print "Command: ", (join " ", @_);
  return 1;
}

sub mail {
  my ($body, $address, $subject, @attachments) = @_;
  my @args;
  push @args, "-a", $_ foreach @attachments;
  push @args, "-s", $subject if $subject;
  if ($address) {
    push @args, $address;
  } else {
    push @args, "-t";
    $address = "(recipient given in message)";
  }
  unless ($dry_run_flag) {
    open(FILE, "|-", "s-nail", @args);
    print FILE wrap('', '', ($body));
    close FILE or die "mail to $address failed\n";
  } else {
    print wrap('', '', "Email to: $address\n$subject\n\n$body\n");
  }
}

my $methods = join ", ", keys %releaser;

sub usage {
  my ($exit_code) = @_;
  print STDERR <<END;
$prog [OPTION...] METHODS [VARIABLE=value...]
Release a program.

METHODS is a comma-separated list of methods, from:
  $methods

  --dry-run            don't do anything, just display what would be done
  --vars               display the variables needed by METHODS and exit
  --help               display this help and exit
  --version            display version information and exit
END
  exit $exit_code;
}

# Get arguments
my $opts = GetOptions(
  "dry-run", \$dry_run_flag,
  "help" => \$help_flag,
  "version" => \$version_flag,
  "vars" => \$vars_flag,
 ) or usage(1);
if ($version_flag) {
  print STDERR $version_banner;
  exit 0;
}
usage(0) if $help_flag;
usage(1) if $#ARGV == -1;
my @methods = split /,/, shift;
foreach my $arg (@ARGV) {
  $arg =~ s/([A-Za-z0-9_]+)\s*=\s*(.*)/$vars{$1} = $2/e;
}

# Check all methods are known
@methods = grep {
  if (!defined($releaser{$_})) {
    die "no such method $_\n";
  } else {
    1;
  }
} @methods;

# Make a set of all needed variables
my $needed = Set::Scalar->new();
$needed = $needed->union($releaser{$_}{vars}) foreach @methods;

# Write release notes if needed
if ($needed->has("notes")) {
  $vars{notes} ||= "release-notes";
  if (!-e $vars{notes}) {
    die "VISUAL is not set; please set it!\n"
      if -z $ENV{VISUAL};
    system($ENV{VISUAL} . " " . $vars{notes}) == 0 or die "editor failed\n";
  }
}

# Complain about missing variables
my $missing = 0;
foreach my $e ($needed->elements) {
  unless ($vars{$e}) {
    print STDERR "Variable $e missing\n";
    $missing = 1;
  }
}
if ($vars_flag || $missing) {
  print STDERR "Variables needed:\n";
  print STDERR "  $_: $var_help{$_}\n" foreach (sort $needed->elements);
  exit $missing;
}

# Welease!
for my $method (@methods) {
  $releaser{$method}{release}();
}
