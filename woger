#!/usr/bin/env perl
# Woger - make a release
my $version_banner = <<END;
Woger welease 18
Copyright (c) Reuben Thomas 2007-2011
Released under the GPL version 3, or (at your option) any later version.
END

use 5.10.0;

use warnings;
use strict;

# FIXME: Add methods rsync (e.g. for web sites), log (to announce on my log)

# Dependencies:
#   For email: mail
#   For SourceForge: copher: http://copher.sourceforge.net/
#   For Freshmeat: Snake Steak: http://repo.cat-v.org/snake_steak/
use Term::ReadLine;
use Perl6::Slurp;
use Text::Wrap;
use Set::Scalar;

use File::Basename;
use Getopt::Long;

my $prog = basename($0);

my %var_help = (
  package => "package base name",
  package_name => "package text name",
  version => "version number",
  description => "short project description",
  notes => "release notes file (need not exist)",
  home => "home page URL",
  upload => "upload URL",
);

my $term = Term::ReadLine->new($prog);


# Release methods

my %releaser = ();
my %vars;

my $have_term_readkey = eval {require Term::ReadKey} // 0;

sub read_password {
  my $prompt = shift // 'Password';
  if ($have_term_readkey) {
    Term::ReadKey::ReadMode('noecho');
  } else {
    $prompt = $prompt . ' (will be shown)';
  }
  my $retval = $term->readline($prompt . ': ');
  if ($have_term_readkey) {
    print "\n"; # if noecho was on, CR wasn't printed
    Term::ReadKey::ReadMode('restore');
  }
  return $retval;
}

%{$releaser{null}} = (
  vars => Set::Scalar->new,
  release => sub {
  }
 );

%{$releaser{sourceforge}} = (
  vars => Set::Scalar->new("notes", "package", "version"),
  getinfo => sub {
    my $self = shift;
    $$self{user} = $term->readline("SourceForge login: ");
    $$self{password} = $term->read_password();
  },
  release => sub {
    my $self = shift;
    system("copher", "-u", $$self{user}, "-P", $$self{password}, "-p",
      $vars{package}, "-k", $vars{package}, "-r", $vars{version}, "-N", $vars{notes}, "$vars{package}-$vars{version}.tar.gz") == 0
        or die "copher failed\n";
    unlink "out.html";
  }
 );

%{$releaser{freshmeat}} = (
  vars => Set::Scalar->new("package", "notes", "version"),
  release => sub {
    my $self = shift;
    open(FILE, "|-", "ss.py", "release", $vars{package}, $vars{version});
    print FILE slurp($vars{notes});
    close FILE or die "Snake Steak failed\n";
  }
 );

%{$releaser{gnu}} = (
  vars => Set::Scalar->new("notes", "package", "package_name", "upload", "version"),
  release => sub {
    # FIXME: Get the command in the next line from the output of make {alpha,beta,stable}
    system("./build-aux/gnupload", "--to", "$vars{upload}:$vars{package}", "$vars{package}-$vars{version}.tar.gz") == 0
      or die "gnupload failed\n";

    my $url = "$vars{upload}/gnu/$vars{package}/$vars{package}-$vars{version}.tar";

    # Wait for URL to become available:
    for (my $i = 0; $i < 100; $i++) {
      system "wget", "--quiet", "-O", "-", "$url.gz.sig" and last;
      sleep 10;
    }

    # Download and verify xz and gz signatures
    # FIXME: Get correct suffixes (e.g. xz xz.sig bz2 bz2.sig) automatically
    for my $i ("gz", "gz.sig") {
      system "wget", "--quiet", "$url.$i" or last;
      system "gpg", "--verify", basename($url) . ".$i" if $i =~ /\.sig$/;
    }
    my $message = slurp($vars{notes});
    mail("info-gnu\@gnu.org", "$vars{package_name} $vars{version} released", $message);
  }
 );

%{$releaser{"lua-l"}} = (
  vars => Set::Scalar->new("package", "package_name", "notes", "description"),
  release => sub {
    my $release_notes = slurp($vars{notes});
    $vars{home} ||= "http://luaforge.net/projects/$vars{package}";
    my $message = <<END;
I am happy to announce the release of $vars{package_name} $vars{version},
$vars{description}.

$release_notes

Get it from $vars{home}
END
    mail("lua-l\@lists.lua.org", "[ANN] $vars{package_name} $vars{version} released", $message);
  }
 );


sub mail {
  my ($address, $subject, $body) = @_;
  open(FILE, "|-", "mail", "-s", $subject, $address);
  print FILE wrap('', '', ($body));
  close FILE or die "mail failed\n";
}

my $methods = join ", ", keys %releaser;

sub usage {
  my ($exit_code) = @_;
  print STDERR <<END;
$prog [OPTION...] METHODS [VARIABLE=value...]
Release a program.

  METHODS is a comma-separated list of methods, from:
    $methods

 Options:
  --vars                     display the variables needed by METHODS and exit
  --help                     display this help and exit
  --version                  display version information and exit
END
  exit $exit_code;
}

# Get arguments
my ($help_flag, $version_flag, $vars_flag);
my $opts = GetOptions(
  "help" => \$help_flag,
  "version" => \$version_flag,
  "vars" => \$vars_flag,
) or usage(1);
if ($version_flag) {
  print STDERR $version_banner;
  exit 0;
}
usage(0) if $help_flag or $#ARGV == -1;
my @methods = split /,/, shift;
foreach my $arg (@ARGV) {
  $arg =~ s/([A-Za-z0-9_]+)\s*=\s*(.*)/$vars{$1} = $2/e;
}
my $needed = Set::Scalar->new();
$needed = $needed->union($releaser{$_}{vars}) foreach @methods;
my $missing;
foreach my $e ($needed->elements) {
  $missing = 1 unless $vars{$e};
}
if ($vars_flag || $missing) {
  print STDERR "Variables needed:\n";
  print STDERR "  $_: $var_help{$_}\n" foreach (sort $needed->elements);
  exit $missing;
}

# Write release notes if non-existent
if (!-e $vars{notes}) {
  die "VISUAL is not set; please set it!\n"
    if -z $ENV{VISUAL};
  system($ENV{VISUAL}, $vars{notes}) == 0 or die "editor failed\n";
}

# Filter out unknown methods
@methods = grep {
  if (!defined ($releaser{$_})) {
    warn "no method $_; ignoring\n";
    0;
  } else {
    1;
  }
} @methods;

# Welease!
for my $method (@methods) {
  $releaser{$method}{getinfo}($releaser{$method})
    if $releaser{$method}{getinfo};
}
for my $method (@methods) {
  $releaser{$method}{release}($releaser{$method});
}
